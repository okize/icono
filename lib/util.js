var Promise, SvgOptimize, _, fs, mime, msg, path, pretty, proc, svgo;

Promise = require('bluebird');

SvgOptimize = require('svgo');

svgo = Promise.promisifyAll(new SvgOptimize());

fs = Promise.promisifyAll(require('fs'));

proc = Promise.promisifyAll(require('child_process'));

path = require('path');

mime = require('mime');

_ = require('lodash');

pretty = require('cssbeautify');

msg = require(path.resolve(__dirname, './', 'msg'));

module.exports = {
  trimFilename: function(filename) {
    var index;
    index = filename.lastIndexOf('.css');
    if (index !== -1) {
      filename = filename.substring(0, index);
    }
    return filename;
  },
  encodeImage: function(data, type, format) {
    var encoded, formatMap, str;
    str = ',';
    formatMap = {
      'svg': '\'data:image/svg+xml',
      'png': '\'data:image/png'
    };
    if (type === 'base64') {
      str = ';base64,';
      encoded = new Buffer(data).toString('base64');
    } else {
      encoded = encodeURIComponent(new Buffer(data).toString());
    }
    return formatMap[format] + str + encoded + '\'';
  },
  roundNum: function(num) {
    return Math.round(num).toString();
  },
  hasSpace: function(filename) {
    return filename.indexOf(' ') >= 0;
  },
  replaceSpaceInFilename: function(oldFilename, newFilename, inDir) {
    return fs.renameSync(inDir + '/' + oldFilename, inDir + '/' + newFilename);
  },
  trimExt: function(filename) {
    return filename.replace(/\.[^\/.]+$/, '');
  },
  filterNonSvgFiles: function(files, dir) {
    return _.filter(files, function(file) {
      return fs.statSync(path.join(dir + '/' + file)).isFile() === true && mime.lookup(file) === 'image/svg+xml';
    });
  },
  optimizeSvg: function(data) {
    return svgo.optimizeAsync(data)["catch"](function(result) {
      _.assign(result, {
        original: data
      });
      return result;
    });
  },
  saveSvgAsPng: function(sourceFileName, destinationFileName, height, width) {
    var args, phantomjs, svgToPngFile;
    phantomjs = path.resolve(__dirname, '../node_modules/phantomjs/bin/', 'phantomjs');
    svgToPngFile = path.resolve(__dirname, './', 'svgToPng.js');
    args = [phantomjs, svgToPngFile, sourceFileName, destinationFileName, height, width];
    return proc.execFileAsync(process.execPath, args).then(function(stdout, stderr) {
      if (stdout[0].length > 0) {
        throw new Error(stdout[0].toString().trim());
      } else {
        return destinationFileName;
      }
    })["catch"](function(error) {
      return msg.log('error', 'svgNotFound', sourceFileName);
    });
  },
  createCssRules: function(results, opts) {
    var css, cssClassnamePrefix, cssNoDataUri, cssNoInlineSvg, cssSvg;
    cssClassnamePrefix = opts.classname != null ? opts.classname : '';
    css = [];
    cssSvg = '';
    cssNoInlineSvg = '';
    cssNoDataUri = '';
    if (!opts.killcomment) {
      cssSvg += '/* generated by iconr */\n\n';
    }
    _.each(results, function(res, i) {
      var height, width;
      height = !isNaN(res.height) ? "height:" + res.height + "px;" : '';
      width = !isNaN(res.width) ? "width:" + res.width + "px;" : '';
      cssSvg += ("." + (cssClassnamePrefix + res.name) + "{") + ("" + height) + ("" + width) + ("background-image:url(" + res.svgdatauri + ");") + "}";
      if (!opts.nopngdata) {
        cssNoInlineSvg += (".no-inlinesvg ." + (cssClassnamePrefix + res.name) + "{") + ("background-image:url(" + res.pngdatauri + ");") + "}";
      }
      if (!opts.nopng && !opts.stdout) {
        return cssNoDataUri += (".no-datauri ." + (cssClassnamePrefix + res.name) + "{") + ("background-image:url('" + res.pngpath + "');") + "}";
      }
    });
    css.push(cssSvg, cssNoInlineSvg, cssNoDataUri);
    return css;
  },
  prettyCss: function(css) {
    return pretty(css);
  },
  mungeCss: function(cssArray) {
    var css;
    css = cssArray.join('');
    return css;
  },
  saveCss: function(filename, cssArr, opts) {
    var css, ref, ref1;
    if (opts.separatecss) {
      if (opts.pretty) {
        cssArr = cssArr.map((function(_this) {
          return function(css) {
            return _this.prettyCss(css);
          };
        })(this));
      }
      fs.writeFileAsync(filename + '.css', cssArr[0]);
      if (((ref = cssArr[1]) != null ? ref.length : void 0) !== 0) {
        fs.writeFileAsync(filename + '-noinlinesvg.css', cssArr[1]);
      }
      if (((ref1 = cssArr[2]) != null ? ref1.length : void 0) !== 0) {
        return fs.writeFileAsync(filename + '-nodatauri.css', cssArr[2]);
      }
    } else {
      css = this.mungeCss(cssArr);
      if (opts.pretty) {
        css = this.prettyCss(css);
      }
      return fs.writeFileAsync(filename + '.css', css);
    }
  }
};
