'use strict';

var Bluebird = require('bluebird');
var fs = Bluebird.promisifyAll(require('fs'));
var proc = Bluebird.promisifyAll(require('child_process'));
var path = require('path');
var mime = require('mime');
var _ = require('lodash');
var pretty = require('cssbeautify');
var msg = require(path.resolve(__dirname, './', 'msg'));
var SvgOptimize = require('svgo');

module.exports = {

  // trims file extension from filename
  trimExt: function trimExt(filename) {
    return filename.replace(/\.[^\/.]+$/, '');
  },

  // returns binary data as encoded string
  encodeImage: function encodeImage(data, type, format) {
    var encoded = '';
    var str = ',';
    var formatMap = {
      'svg': '\'data:image/svg+xml',
      'png': '\'data:image/png'
    };
    if (type === 'base64') {
      str = ';base64,';
      encoded = new Buffer(data).toString('base64');
    } else {
      encoded = encodeURIComponent(new Buffer(data).toString());
    }
    return formatMap[format] + str + encoded + '\'';
  },

  // returns a rounded string from a float or string
  roundNum: function roundNum(num) {
    return Math.round(num).toString();
  },

  // checks if there are spaces in the filename
  hasSpace: function hasSpace(filename) {
    return filename.indexOf(' ') >= 0;
  },

  // replaces spaces in filenames with dashes
  replaceSpaceInFilename: function replaceSpaceInFilename(oldFilename, newFilename, inDir) {
    return fs.renameSync(inDir + '/' + oldFilename, inDir + '/' + newFilename);
  },

  // removes files from a list that aren't SVG images
  filterNonSvgFiles: function filterNonSvgFiles(files, dir) {
    return _.filter(files, function (file) {
      var isFile = fs.statSync(path.join(dir + '/' + file)).isFile() === true;
      var isSvg = mime.lookup(file) === 'image/svg+xml';
      return isFile && isSvg;
    });
  },

  // returns an optimized SVG data string as a promise
  // also appends the original SVG data to the SVGO output
  optimizeSvg: function optimizeSvg(data) {
    var svgo = Bluebird.promisifyAll(new SvgOptimize());
    return svgo.optimizeAsync(data)['catch'](function (result) {
      // I have no idea why this needs to be done in a catch block
      _.assign(result, { original: data });
      return result;
    });
  },

  // spins up phantomjs and saves SVGs as PNGs
  // phantomjs will output WARNINGS to stderr so ignore for now
  saveSvgAsPng: function saveSvgAsPng(sourceFileName, destinationFileName, height, width) {
    var phantomjs = path.resolve(__dirname, '../node_modules/phantomjs/bin/', 'phantomjs');
    var svgToPngFile = path.resolve(__dirname, './', 'svgToPng.js');
    var args = [phantomjs, svgToPngFile, sourceFileName, destinationFileName, height, width];
    return proc.execFileAsync(process.execPath, args).then(function (stdout) {
      if (stdout[0].length > 0) {
        throw new Error(stdout[0].toString().trim());
      } else {
        return destinationFileName;
      }
    })['catch'](function () {
      return msg.log('error', 'svgNotFound', sourceFileName);
    });
  },

  // returns a string that can be saved as a CSS file
  createCssRules: function createCssRules(results, opts) {
    var cssClassnamePrefix = opts.classname !== null ? opts.classname : '';
    var css = [];
    var cssSvg = '';
    var cssNoInlineSvg = '';
    var cssNoDataUri = '';
    if (!opts.killcomment) {
      cssSvg += '/* generated by iconr */\n\n';
    }

    _.each(results, function (result) {
      var height = !isNaN(result.height) ? 'height:' + result.height + 'px;' : '';
      var width = !isNaN(result.width) ? 'width:' + result.width + 'px;' : '';
      cssSvg += '.#' + (cssClassnamePrefix + result.name) + '{' + height + width + 'background-image:url("' + result.svgdatauri + '");}';
      if (!opts.nopngdata) {
        cssNoInlineSvg += '.no-inlinesvg .' + (cssClassnamePrefix + result.name) + '{background-image:url("' + result.pngdatauri + '");}';
      }
      if (!opts.nopng && !opts.stdout) {
        cssNoDataUri += '.no-datauri .' + (cssClassnamePrefix + result.name) + '{background-image:url("' + result.pngpath + '");}';
      }
    });

    css.push(cssSvg, cssNoInlineSvg, cssNoDataUri);

    return css;
  },

  // returns a "beautified" version of a css string
  prettyCss: function prettyCss(css) {
    return pretty(css);
  },

  // merge the css array into a string
  mungeCss: function mungeCss(cssArray) {
    return cssArray.join('');
  },

  // saves CSS file(s) to disk
  saveCss: function saveCss(filename, cssArr, opts) {

    // save separate css files
    if (opts.separatecss) {

      // prettify the CSS if necessary
      if (opts.pretty) {
        cssArr = cssArr.map(function (cssStr) {
          return pretty(cssStr);
        });
      }

      // save CSS with SVG data URIs
      fs.writeFileAsync(filename + '.css', cssArr[0]);

      // save CSS with fallback PNG data URIs
      if (!opts.nopngdata && cssArr[1].length !== 0) {
        fs.writeFileAsync(filename + '-noinlinesvg.css', cssArr[1]);
      }

      // save CSS with fallback PNG image paths
      if (!opts.nopng && cssArr[2].length !== 0) {
        fs.writeFileAsync(filename + '-nodatauri.css', cssArr[2]);
      }
    } else {

      // combine CSS into string
      var css = undefined.mungeCss(cssArr);

      // prettify the CSS if necessary
      if (opts.pretty) {
        css = undefined.prettyCss(css);
      }

      // write CSS into a single file
      fs.writeFileAsync(filename + '.css', css);
    }

    return;
  }

};