// Generated by CoffeeScript 1.6.3
var Q, colors, fs, microtime, msg, path, pathExists, readDir, readFile, util, writeFile, _;

fs = require('fs');

path = require('path');

_ = require('underscore');

Q = require('q');

colors = require('colors');

microtime = require('microtime');

util = require(path.resolve(__dirname, './', 'util'));

msg = require(path.resolve(__dirname, './', 'msg'));

readDir = Q.denodeify(fs.readdir);

readFile = Q.denodeify(fs.readFile);

writeFile = Q.denodeify(fs.writeFile);

pathExists = Q.denodeify(fs.exists);

module.exports = function(args, opts) {
  var cssFilename, iconrHeader, inDir, log, outDir, results;
  inDir = path.resolve(__dirname, '..', 'test', 'inDir');
  outDir = path.resolve(__dirname, '..', 'test', 'outDir');
  cssFilename = 'iconr.css';
  iconrHeader = '/* generated by iconr */\n\n';
  results = [];
  if (opts.verbose) {
    log = {
      appStart: microtime.now(),
      appEnd: 0,
      svgCount: 0,
      svgSize: 0
    };
  }
  if (opts.verbose) {
    msg.log('info', 'appStart');
  }
  return pathExists(inDir, function(exists) {
    if (exists) {
      return readDir(inDir).then(function(files) {
        if (opts.verbose) {
          msg.log('info', 'filterNonSvg');
        }
        return util.filterNonSvgFiles(files);
      }).then(function(filteredFiles) {
        var queue;
        if (opts.verbose) {
          msg.log('info', 'readingSvg');
        }
        if (opts.verbose) {
          log.svgCount = filteredFiles.length;
        }
        queue = [];
        filteredFiles.forEach(function(file) {
          var svgPath;
          svgPath = path.resolve(inDir, file);
          queue.push(readFile(svgPath, 'utf8'));
          if (opts.verbose) {
            log.svgSize += fs.statSync(svgPath).size;
          }
          return results.push({
            name: util.trimExt(file),
            svgpath: svgPath
          });
        });
        return Q.all(queue);
      }).then(function(svgData) {
        var queue;
        if (opts.verbose) {
          msg.log('info', 'optimizingSvg');
        }
        queue = [];
        svgData.forEach(function(svg) {
          return queue.push(util.optimizeSvg(svg));
        });
        return Q.all(queue);
      }).then(function(data) {
        if (opts.verbose) {
          msg.log('info', 'encodingSvg');
        }
        return _.each(data, function(obj, i) {
          var svgData;
          svgData = {
            svgsrc: obj.data,
            svgdatauri: util.encodeImage(obj.data, 'base64', 'svg'),
            height: util.roundNum(obj.info.height),
            width: util.roundNum(obj.info.width)
          };
          return _.extend(results[i], svgData);
        });
      }).then(function() {
        var queue;
        if (opts.verbose) {
          msg.log('info', 'convertingSvg');
        }
        queue = [];
        _.each(results, function(obj) {
          var destFile;
          destFile = path.resolve(outDir, obj.name + '.png');
          return queue.push(util.saveSvgAsPng(obj.svgpath, destFile));
        });
        return Q.all(queue);
      }).then(function(pngPaths) {
        var queue;
        if (opts.verbose) {
          msg.log('info', 'readingPng');
        }
        queue = [];
        pngPaths.forEach(function(path, i) {
          queue.push(readFile(path, 'utf8'));
          return _.extend(results[i], {
            pngpath: path
          });
        });
        return Q.all(queue);
      }).then(function(pngData) {
        if (opts.verbose) {
          msg.log('info', 'encodingPng');
        }
        return pngData.forEach(function(data, i) {
          return _.extend(results[i], {
            pngdatauri: util.encodeImage(data, 'base64', 'png')
          });
        });
      }).then(function() {
        if (opts.verbose) {
          msg.log('info', 'generatingCss');
        }
        return iconrHeader + util.createCssRules(results);
      }).then(function(cssString) {
        if (opts.verbose) {
          msg.log('info', 'saveCss');
        }
        if (opts.pretty) {
          cssString = util.prettyCss(cssString);
        }
        return writeFile(path.resolve(outDir, '..', cssFilename), cssString);
      }).fail(function(error) {
        return msg.data('error', error);
      })["finally"](function() {
        if (opts.debug) {
          msg.dump(results);
        }
        if (opts.verbose) {
          msg.log('info', 'appEnd');
        }
        if (opts.verbose) {
          log.appEnd = microtime.now();
          return msg.summary(log);
        }
      }).done();
    } else {
      return msg.log('error', 'wrongDirectory');
    }
  });
};
