// Generated by CoffeeScript 1.6.3
var Q, fs, log, path, pathExists, pretty, readDir, readFile, util, writeFile, _;

fs = require('fs');

path = require('path');

_ = require('underscore');

Q = require('q');

util = require(path.resolve(__dirname, './', 'util'));

log = require(path.resolve(__dirname, './', 'log'));

pretty = require('PrettyCSS');

readDir = Q.denodeify(fs.readdir);

readFile = Q.denodeify(fs.readFile);

writeFile = Q.denodeify(fs.writeFile);

pathExists = Q.denodeify(fs.exists);

module.exports = function(args) {
  var inDir, outDir, results;
  console.time('time-to-run');
  inDir = path.resolve(__dirname, '..', 'test', 'inDir');
  outDir = path.resolve(__dirname, '..', 'test', 'outDir');
  results = [];
  return pathExists(inDir, function(exists) {
    if (exists) {
      return readDir(inDir).then(function(files) {
        return util.filterNonSvgFiles(files);
      }).then(function(filteredFiles) {
        var queue;
        queue = [];
        filteredFiles.forEach(function(file) {
          var svgPath;
          svgPath = path.resolve(inDir, file);
          queue.push(readFile(svgPath, 'utf8'));
          return results.push({
            name: util.trimExt(file),
            svgpath: svgPath
          });
        });
        return Q.all(queue);
      }).then(function(svgData) {
        var queue;
        queue = [];
        svgData.forEach(function(svg) {
          return queue.push(util.optimizeSvg(svg));
        });
        return Q.all(queue);
      }).then(function(data) {
        return _.each(data, function(obj, i) {
          var svgData;
          svgData = {
            svgsrc: obj.data,
            svgdatauri: util.encodeImage(obj.data, 'base64', 'svg'),
            height: util.roundNum(obj.info.height),
            width: util.roundNum(obj.info.width)
          };
          return _.extend(results[i], svgData);
        });
      }).then(function() {
        var queue;
        queue = [];
        _.each(results, function(obj) {
          var destFile;
          destFile = path.resolve(outDir, obj.name + '.png');
          return queue.push(util.saveSvgAsPng(obj.svgpath, destFile));
        });
        return Q.all(queue);
      }).then(function(pngPaths) {
        var queue;
        queue = [];
        pngPaths.forEach(function(path, i) {
          queue.push(readFile(path, 'utf8'));
          return _.extend(results[i], {
            pngpath: path
          });
        });
        return Q.all(queue);
      }).then(function(pngData) {
        return pngData.forEach(function(data, i) {
          return _.extend(results[i], {
            pngdatauri: util.encodeImage(data, 'base64', 'png')
          });
        });
      }).then(function() {
        var css;
        return css = util.createCss(results);
      }).then(function() {}).fail(function(error) {
        return log.data('error', error);
      })["finally"](function() {
        return console.timeEnd('time-to-run');
      }).done();
    } else {
      return log.msg('error', 'wrongDirectory');
    }
  });
};
