// Generated by CoffeeScript 1.6.3
var Progger, Q, colors, fs, microtime, mkdirp, msg, p, path, pathExists, readDir, readFile, util, writeFile, _;

fs = require('fs');

path = require('path');

_ = require('underscore');

Q = require('q');

colors = require('colors');

microtime = require('microtime');

mkdirp = require('mkdirp');

Progger = require('progger');

p = new Progger({
  speed: 100,
  token: '.',
  color: 'blue'
});

util = require(path.resolve(__dirname, './', 'util'));

msg = require(path.resolve(__dirname, './', 'msg'));

readDir = Q.denodeify(fs.readdir);

readFile = Q.denodeify(fs.readFile);

writeFile = Q.denodeify(fs.writeFile);

pathExists = Q.denodeify(fs.exists);

module.exports = function(args, opts) {
  var cssFilename, iconrHeader, inDir, log, outDir, pngDir, results, showSummary;
  inDir = path.resolve(args[0]);
  if (!fs.existsSync(inDir)) {
    return msg.log('error', 'wrongDirectory');
  }
  if (args.length < 2) {
    return msg.log('error', 'noOutDir');
  }
  outDir = path.resolve(args[1]);
  pngDir = outDir + '/images';
  if (!fs.existsSync(outDir)) {
    mkdirp(pngDir);
  }
  cssFilename = 'iconr.css';
  iconrHeader = '/* generated by iconr */\n\n';
  showSummary = true;
  results = [];
  if (opts.verbose) {
    log = {
      appStart: microtime.now(),
      appEnd: 0,
      svgCount: 0,
      svgSize: 0,
      cssSize: 0
    };
  }
  if (opts.verbose) {
    msg.log('info', 'appStart');
  }
  return readDir(inDir).then(function(files) {
    if (opts.verbose) {
      msg.log('info', 'filterNonSvg');
    }
    return util.filterNonSvgFiles(files, inDir);
  }).then(function(filteredFiles) {
    var queue;
    if (filteredFiles.length < 1) {
      showSummary = false;
      return msg.log('error', 'noSvg');
    }
    if (opts.verbose) {
      msg.log('info', 'readingSvg');
    }
    if (opts.verbose) {
      log.svgCount = filteredFiles.length;
    }
    queue = [];
    filteredFiles.forEach(function(file) {
      var svgPath;
      svgPath = path.resolve(inDir, file);
      queue.push(readFile(svgPath, 'utf8'));
      if (opts.verbose) {
        log.svgSize += fs.statSync(svgPath).size;
      }
      return results.push({
        name: util.trimExt(file),
        svgpath: svgPath
      });
    });
    return Q.all(queue);
  }).then(function(svgData) {
    var queue;
    if (opts.verbose) {
      msg.log('info', 'optimizingSvg');
    }
    queue = [];
    svgData.forEach(function(svg) {
      return queue.push(util.optimizeSvg(svg));
    });
    return Q.all(queue);
  }).then(function(data) {
    if (opts.verbose) {
      msg.log('info', 'encodingSvg');
    }
    return _.each(data, function(obj, i) {
      var encoding, svgData;
      encoding = opts.base64 ? 'base64' : '';
      svgData = {
        svgsrc: obj.data,
        svgdatauri: util.encodeImage(obj.data, encoding, 'svg'),
        height: util.roundNum(obj.info.height),
        width: util.roundNum(obj.info.width)
      };
      return _.extend(results[i], svgData);
    });
  }).then(function() {
    var queue;
    if (opts.verbose) {
      msg.log('info', 'convertingSvg');
    }
    queue = [];
    _.each(results, function(obj) {
      var destFile;
      destFile = path.resolve(pngDir, obj.name + '.png');
      return queue.push(util.saveSvgAsPng(obj.svgpath, destFile));
    });
    p.start();
    return Q.all(queue);
  }).then(function(pngPaths) {
    var queue;
    p.stop();
    if (opts.verbose) {
      msg.log('info', 'readingPng');
    }
    queue = [];
    pngPaths.forEach(function(path, i) {
      var pngpath;
      queue.push(readFile(path, null));
      pngpath = path.replace(outDir, '.');
      return _.extend(results[i], {
        pngpath: pngpath
      });
    });
    return Q.all(queue);
  }).then(function(pngData) {
    if (opts.verbose) {
      msg.log('info', 'encodingPng');
    }
    return pngData.forEach(function(data, i) {
      return _.extend(results[i], {
        pngdatauri: util.encodeImage(data, 'base64', 'png')
      });
    });
  }).then(function() {
    if (opts.verbose) {
      msg.log('info', 'generatingCss');
    }
    return iconrHeader + util.createCssRules(results);
  }).then(function(cssString) {
    if (opts.verbose) {
      msg.log('info', 'saveCss');
    }
    if (opts.pretty) {
      cssString = util.prettyCss(cssString);
    }
    if (opts.verbose) {
      log.cssSize = cssString.length;
    }
    return writeFile(path.resolve(outDir, cssFilename), cssString);
  }).then(function() {
    var tooLarge;
    tooLarge = 32768;
    return results.forEach(function(res) {
      var size;
      size = res.pngdatauri.length;
      if (size >= tooLarge) {
        return msg.log('warn', 'largeDataUri', res.name + ' (' + size + ' bytes)');
      }
    });
  }).then(function() {
    if (opts.verbose) {
      return msg.log('info', 'appEnd');
    }
  }).fail(function(error) {
    if (opts.debug) {
      console.log(error.stack);
    }
    return showSummary = false;
  })["finally"](function() {
    if (opts.summary && showSummary) {
      log.appEnd = microtime.now();
      return msg.summary(log);
    }
  }).done();
};
