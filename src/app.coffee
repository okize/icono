# modules
fs = require 'fs'
path = require 'path'
_ = require 'underscore'
Q = require 'q'
colors = require 'colors'
microtime = require 'microtime'
util = require path.resolve(__dirname, './', 'util')
msg = require path.resolve(__dirname, './', 'msg')

# Q wrappers for some node methods
readDir = Q.denodeify fs.readdir
readFile = Q.denodeify fs.readFile
writeFile = Q.denodeify fs.writeFile
pathExists = Q.denodeify fs.exists

module.exports = (args, opts) ->

  # temp (these will be passed as arguments)
  inDir = path.resolve(__dirname, '..', 'test', 'inDir')
  outDir = path.resolve(__dirname, '..', 'test', 'outDir')
  # results = require(path.resolve(__dirname, '../test', 'results.json'))

  # name of the CSS file output
  cssFilename = 'iconr.css'

  # string to place at the top of the CSS file
  iconrHeader = '/* generated by iconr */\n\n'

  # stores results through the promise chain
  results = []

  # logs data about the application operations
  if opts.verbose
    log =
      appStart: microtime.now()
      appEnd: 0
      svgCount: 0
      svgSize: 0

  # starting app
  msg.log 'info', 'appStart' if opts.verbose

  # confirm input directory exists
  pathExists inDir, (exists) ->

    if exists

      # read files in directory
      readDir(inDir)
        .then( (files) ->

          # filter anything that isn't an SVG
          msg.log 'info', 'filterNonSvg' if opts.verbose

          util.filterNonSvgFiles files

        )
        .then( (filteredFiles) ->

          # read SVGs into memory
          msg.log 'info', 'readingSvg' if opts.verbose

          # log icon count
          log.svgCount = filteredFiles.length if opts.verbose

          queue = []

          filteredFiles.forEach (file) ->
            svgPath = path.resolve inDir, file
            queue.push readFile(svgPath, 'utf8')

            # log total file size of the SVG files we're optimizing
            log.svgSize += fs.statSync(svgPath).size if opts.verbose

            # add to results
            results.push
              name: util.trimExt file
              svgpath: svgPath

          Q.all(queue)

        )
        .then( (svgData) ->

          # optimize SVG data and get width & heights
          msg.log 'info', 'optimizingSvg' if opts.verbose

          queue = []

          svgData.forEach (svg) ->
            queue.push util.optimizeSvg(svg)

          Q.all(queue)

        )
        .then( (data) ->

          # merge compressed & encoded SVG data into results
          msg.log 'info', 'encodingSvg' if opts.verbose

          _.each data, (obj, i) ->

            svgData =
              svgsrc: obj.data
              svgdatauri: util.encodeImage(obj.data, 'base64', 'svg')
              height: util.roundNum(obj.info.height)
              width: util.roundNum(obj.info.width)

            _.extend results[i], svgData

        )
        .then( ->

          # convert SVGs to PNGs
          msg.log 'info', 'convertingSvg' if opts.verbose

          queue = []

          _.each results, (obj) ->
            destFile = path.resolve(outDir, obj.name + '.png')
            queue.push util.saveSvgAsPng(obj.svgpath, destFile)

          Q.all(queue)

        )
        .then( (pngPaths) ->

          # read PNGs into memory
          msg.log 'info', 'readingPng' if opts.verbose

          queue = []

          pngPaths.forEach (path, i) ->
            queue.push readFile(path, 'utf8')
            _.extend results[i], pngpath: path # add to results

          Q.all(queue)

        )
        .then( (pngData) ->

          # convert PNGs to data strings
          msg.log 'info', 'encodingPng' if opts.verbose

          pngData.forEach (data, i) ->
            _.extend results[i], pngdatauri: util.encodeImage(data, 'base64', 'png') # add to results

        )
        .then( ->

          # generate a string of CSS rules from the results
          msg.log 'info', 'generatingCss' if opts.verbose

          iconrHeader + util.createCssRules results

        )
        .then( (cssString) ->

          # save generated CSS to file
          msg.log 'info', 'saveCss' if opts.verbose

          # if pretty print is required
          cssString = util.prettyCss cssString if opts.pretty

          writeFile path.resolve(outDir, '..', cssFilename), cssString

        )
        .fail( (error) ->

          # errors should output here
          msg.data 'error', error

        )
        .finally( ->

          # in debug mode also expose results object
          msg.dump results if opts.debug

          # finished!
          msg.log 'info', 'appEnd' if opts.verbose

          # log a summary message if in verbose mode
          if opts.verbose
            log.appEnd = microtime.now()
            msg.summary log

        )
        .done()

    else
      msg.log 'error', 'wrongDirectory'
