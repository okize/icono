const Bluebird = require('bluebird');
const fs = Bluebird.promisifyAll(require('fs'));
const path = require('path');
const mime = require('mime');
const _ = require('lodash');
const pretty = require('cssbeautify');

module.exports = {

  // trims file extension from filename
  trimExt: (filename) => {
    return filename.replace(/\.[^\/.]+$/, '');
  },

  // returns a rounded string from a float or string
  roundNum: (num) => {
    return Math.round(num).toString();
  },

  // checks if there are spaces in the filename
  hasSpace: (filename) => {
    return filename.indexOf(' ') >= 0;
  },

  // replaces spaces in filenames with dashes
  replaceSpaceInFilename: (oldFilename, newFilename, inDir) => {
    return fs.renameSync(inDir + '/' + oldFilename, inDir + '/' + newFilename);
  },

  // removes files from a list that aren't SVG images
  filterNonSvgFiles: (files, dir) => {
    return _.filter(files, (file) => {
      let isFile = fs.statSync(path.join(dir + '/' + file)).isFile() === true;
      let isSvg = mime.lookup(file) === 'image/svg+xml';
      return isFile && isSvg;
    });
  },

  // returns a string that can be saved as a CSS file
  createCssRules: (results, opts) => {
    const cssClassnamePrefix = opts.classname !== null ? opts.classname : '';
    let css = [];
    let cssSvg = '';
    let cssNoInlineSvg = '';
    let cssNoDataUri = '';
    if (!opts.killcomment) {
      cssSvg += '/* generated by iconr */\n\n';
    }

    _.each(results, (result) => {
      let height = !isNaN(result.height) ? 'height:' + result.height + 'px;' : '';
      let width = !isNaN(result.width) ? 'width:' + result.width + 'px;' : '';
      cssSvg += '.#' + (cssClassnamePrefix + result.name) + '{' + height + width + 'background-image:url("' + result.svgdatauri + '");}';
      if (!opts.nopngdata) {
        cssNoInlineSvg += '.no-inlinesvg .' + (cssClassnamePrefix + result.name) + '{background-image:url("' + result.pngdatauri + '");}';
      }
      if (!opts.nopng && !opts.stdout) {
        cssNoDataUri += '.no-datauri .' + (cssClassnamePrefix + result.name) + '{background-image:url("' + result.pngpath + '");}';
      }
    });

    css.push(cssSvg, cssNoInlineSvg, cssNoDataUri);

    return css;
  },

  // returns a "beautified" version of a css string
  prettyCss: (css) => {
    return pretty(css);
  },

  // merge the css array into a string
  mungeCss: (cssArray) => {
    return cssArray.join('');
  },

  // saves CSS file(s) to disk
  // can't use arrow syntax here because of "this" reference
  saveCss: function saveCss(filename, cssArr, opts) {

    // save separate css files
    if (opts.separatecss) {

      // prettify the CSS if necessary
      let css = opts.pretty ? cssArr.map((cssStr) => pretty(cssStr)) : css;

      // save CSS with SVG data URIs
      fs.writeFileAsync(filename + '.css', css[0]);

      // save CSS with fallback PNG data URIs
      if (!opts.nopngdata && (css[1].length !== 0)) {
        fs.writeFileAsync(filename + '-noinlinesvg.css', css[1]);
      }

      // save CSS with fallback PNG image paths
      if (!opts.nopng && (css[2].length !== 0)) {
        fs.writeFileAsync(filename + '-nodatauri.css', css[2]);
      }

    } else {

      // combine CSS into string
      let css = this.mungeCss(cssArr);

      // prettify the CSS if necessary
      if (opts.pretty) {
        css = this.prettyCss(css);
      }

      // write CSS into a single file
      fs.writeFileAsync(filename + '.css', css);

    }

    return;
  }

};
