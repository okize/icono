# modules
Promise = require('bluebird')
fs = Promise.promisifyAll require('fs')
path = require('path')
execFile = require('child_process').execFile
mime = require('mime')
_ = require('lodash')
Q = require('q')
svgo = new (require('svgo'))()
pretty = require('cssbeautify')
phantomjs = path.resolve(__dirname, '../node_modules/phantomjs/bin/phantomjs')
svgToPngFile = path.resolve(__dirname, './', 'svgToPng.js')

module.exports =

  # remove .css from end of filename if present
  trimFilename: (filename) ->

    index = filename.lastIndexOf('.css')

    if index != -1
      filename = filename.substring 0, index

    filename

  # returns binary data as encoded string
  encodeImage: (data, type, format) ->
    str = ','

    formatMap =
      'svg': '\'data:image/svg+xml',
      'png': '\'data:image/png'

    if type is 'base64'
      str = ';base64,'
      encoded = new Buffer(data).toString 'base64'
    else
      encoded = encodeURIComponent(new Buffer(data).toString())

    formatMap[format] + str + encoded + '\''

  # returns a rounded string from a float or string
  roundNum: (num) ->
    Math.round(num).toString()

  # checks if there are spaces in the filename
  hasSpace: (filename) ->
    filename.indexOf(' ') >= 0

  # replaces spaces in filenames with dashes
  replaceSpaceInFilename: (oldFilename, newFilename, inDir) ->
    fs.renameSync(inDir + '/' + oldFilename, inDir + '/' + newFilename)

  # trims file extension from filename
  trimExt: (filename) ->
    # return filename.split('.')[0]
    filename.replace(/\.[^/.]+$/, '')

  # removes files from a list that aren't SVG images
  filterNonSvgFiles: (files, dir) ->
    _.filter files, (file) ->
      fs.statSync( path.join(dir + '/' + file) ).isFile() == true &&
      mime.lookup(file) == 'image/svg+xml'

  # returns an optimized SVG data string as a promise
  # also appends the original SVG data to the SVGO output
  optimizeSvg: (data) ->
    d = Q.defer()
    svgo.optimize data, (result) ->
      if result.error
        d.reject new Error(result.error)
      result.original = data
      d.resolve result
    d.promise

  # spins up phantomjs and saves SVGs as PNGs
  # phantomjs will output WARNINGS to stderr so ignore for now
  saveSvgAsPng: (sourceFileName, destinationFileName, height, width) ->
    args = [
      phantomjs
      svgToPngFile
      sourceFileName
      destinationFileName
      height
      width
    ]
    d = Q.defer()
    execFile process.execPath, args, (err, stdout, stderr) ->
      if err
        d.reject new Error err
      else if stdout.length > 0
        d.reject new Error stdout.toString().trim()
      else
        d.resolve destinationFileName
    d.promise

  # returns a string that can be saved as a CSS file
  createCssRules: (results, opts) ->

    # string to prefix classnames with
    cssClassnamePrefix = if opts.classname? then opts.classname else ''

    # start with empty strings
    css = []
    cssSvg = ''
    cssNoInlineSvg = ''
    cssNoDataUri = ''

    # string to place at the top of the CSS file
    unless opts.killcomment
      cssSvg += '/* generated by iconr */\n\n'

    _.each results, (res, i) ->
      height = if not isNaN res.height then "height:#{res.height}px;" else ''
      width = if not isNaN res.width then "width:#{res.width}px;" else ''
      cssSvg +=
        ".#{cssClassnamePrefix + res.name}{" +
        "#{height}" +
        "#{width}" +
        "background-image:url(#{res.svgdatauri});" +
        "}"

      # fallback PNG data URI
      unless opts.nopngdata
        cssNoInlineSvg +=
          ".no-inlinesvg .#{cssClassnamePrefix + res.name}{" +
          "background-image:url(#{res.pngdatauri});" +
          "}"

      # fallback PNG images
      if !opts.nopng && !opts.stdout
        cssNoDataUri +=
          ".no-datauri .#{cssClassnamePrefix + res.name}{" +
          "background-image:url('#{res.pngpath}');" +
          "}"

    css.push cssSvg, cssNoInlineSvg, cssNoDataUri

    css

  # returns a "beautified" version of a css string
  prettyCss: (css) ->
    pretty css

  # merge the css array into a string
  mungeCss: (cssArray) ->
    css = cssArray.join ''
    css

  # saves CSS file(s) to disk
  saveCss: (filename, cssArr, opts) ->

    # save separate css files
    if opts.separatecss

      # prettify the CSS if necessary
      if opts.pretty
        cssArr = cssArr.map (css) => @prettyCss css

      # save CSS with SVG data URIs
      fs.writeFileAsync filename + '.css', cssArr[0]

      # save CSS with fallback PNG data URIs
      if cssArr[1].length != 0
        fs.writeFileAsync filename + '-noinlinesvg.css', cssArr[1]

      # save CSS with fallback PNG image paths
      if cssArr[2].length != 0
        fs.writeFileAsync filename + '-nodatauri.css', cssArr[2]

    else

      # combine CSS into string
      css = @mungeCss cssArr

      # prettify the CSS if necessary
      css = @prettyCss css if opts.pretty

      # write CSS into a single file
      fs.writeFileAsync filename + '.css', css
